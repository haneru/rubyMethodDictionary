[
{"class":"Array","name":"*","detail":"*演算子（メソッド）は、左辺の配列arrayの要素を右辺の数intだけ繰り返し並べた配列を作って返します。\n\nexample\n\narr = [1,2]\n\np arr * 2\n\n出力結果\n\n[1,2,1,2]\n\n*の右辺にstrを置くと各要素を文字列に変換しstrを区切りとした文字列を返します。joinメソッドと同じ動作です。\n\nexample\n\narr = [\"one\", \"two\", \"three\"]\n\nputs arr * \", \"\n\n出力結果\n\none,two,three"},
{"class":"Array","name":"+","detail":"+演算子（メソッド）は、2つの配列を連結した新しい配列を作成して返します。\n\nexample\n\nanimals = [\"dog\", \"cat\"]\n\np animals + [\"cow\"]\n\n出力結果\n\n[\"dog\",\"cat\",\"cow\"]"},
{"class":"Array","name":"-","detail":"-演算子（メソッド）は、2つの配列の差集合を作ります。左辺の配列から右辺の配列に含まれる要素を取り除き、新しい配列にして返します。重複している要素は取り除かれますが、左辺で重複していて右辺にはない要素は除かれません。\n\nexample\n\nnum1 = [1,5,4,3,5]\n\nnum2 = [3,4,3,2]\n\np num1 - num2\n\n出力結果\n\n[1,5,5]"},
{"class":"Array","name":"|","detail":"|演算子（メソッド）は、2つの配列の和集合を作ります。2つの配列の要素をすべて集め、重複している要素は取り除かれ、新しい配列にして返します。\n\nexample\n\nnum1 = [1,5,5,2,3]\n\nnum2 = [6,4,2]\n\np num1 | num2\n\n出力結果\n\n[1,5,2,3,6,4]"},
{"class":"Array","name":"<<","detail":"<<演算子（メソッド）は、左辺の配列（レシーバ）の末尾に右辺のオブジェクトを要素として加え、レシーバ自身を変更するメソッドです。戻り値はレシーバ自身です。\n\nexample\n\nanimals = [\"dog\",\"cat\"]\n\nanimals << \"cow\"\n\np animals\n\n出力結果\n\n[\"dog\",\"cat\",\"cow\"]"},
{"class":"Array","name":"<=>","detail":"<=>演算子（メソッド）は、2つの配列の順序を調べます。戻り値が-1なら左辺が先、0なら同じ、1なら右辺が先になります。\n比較の仕方は２つの配列の要素を先頭から順に<=>演算子で調べていき、<=>が0以外の値を返したときは、そこで比較を中断しその値を返し、どちらかの配列の末尾に達した時は、サイズが短い方の配列が先になり、すべての要素で<=>が0を返し、配列のサイズも同じ場合は0を返します。\n左辺の配列の中に<=>を持たない要素があるときはNoMethodErrorが発生します。\n\nexample\n\nnum1 = [1,2,3,4]\n\nnum2 = [1,2,4,4]\n\nnum3 = [1,2,3]\n\nnum4 = [1,2,3,4]\n\nputs num1 <=> arr2\n\nputs num1 <=> num3\n\nputs num1 <=> num4\n\n出力結果\n\n-1\n\n1\n\n0"},
{"class":"Array","name":"[]","detail":"[]メソッドは、配列から引数で指定した位置の要素を取り出して返します。引数には、整数（位置）、整数2つ（位置と数）、範囲を指定できます。sliceメソッドは[]の別名です。\n引数に整数１つを指定したときは、その位置の要素を取り出して返します。#0が一番目、1が二番目...\n引数にマイナスの値を指定したときは、配列の末尾から数えます。#-1が後ろから1番目、-2が後ろから2番目、...\n引数が範囲外のときはnilを返します。\n\nexample\n\nnum = [1,2,3,4]\n\nputs num[1]\n\nputs num[-1]\n\n出力結果\n\n2\n\n4\n\n引数にrangeを指定すると、その範囲の位置から要素を取り出して、配列で返します。rangeが配列の範囲外のときはnilを返し、rangeの開始位置が要素の数と同じときは空の配列を返します。num = [1,2,3,4,5]\n\np num[1..3]\n\np num[1...3]\n\np num[-3..-1]\n\n出力結果\n\n[2,3,4]\n\n[2,3]\n\n[3,4,5]\n\n引数に整数2つ（index、length）を指定したときは、indexの位置からlength個の要素を取り出して、配列で返します。indexが範囲外のときはnilを返します。また、indexが要素の数と同じときは空の配列を返します。\nindexにマイナスの値を指定した時は、配列の末尾から数えます。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num[2,2]\n\np num[-4,2]\n\np num[5,2]\n\n出力結果\n\n[3,4]\n\n[2,3]\n\n[]"},
{"class":"Array","name":"[]=","detail":"[]=メソッドは、array[index] = objのように記述することで、[]内で指定した位置の要素を右辺で置き換えます。arrayがレシーバで、[]内のindexと右辺のobjが引数であり、レシーバ自身を変更するメソッドで、戻り値は常に右辺のobjです。\n\nexample\n\nnum = [1,2,3,4]\n\nnum[1] = 9\n\nnum[-1] = 6\n\np num\n\n出力結果\n\n[1,9,2,3,4,6]"},
{"class":"Array","name":"assoc","detail":"assocメソッドは、配列の配列を連想配列のように扱い、キーに対応する配列を取り出します。配列の配列の中で、最初の要素が引数と同じ配列を探して返し、見つからないときはnilを返します。要素と引数の比較には、==演算子が使われます。1つまたは3つ以上の要素からなる配列の配列でもassocメソッドは使えますし、配列以外の要素や空の配列が混じっていてもエラーにはなりません。\n\nexample\n\nperson = [[\"name\",\"John\"],[\"age\",\"18\"],[\"hobby\",\"baseball\"]]\n\np person.assoc(\"age\")\n\n出力結果\n\n[\"age\",\"18\"]"},
{"class":"Array","name":"at","detail":"atメソッドは、配列から引数で指定した位置の要素を取り出して返し、引数が範囲外のときはnilを返します。[]とは違い、引数に指定できる整数は１つだけです。\n\nexample\n\nnum = [1,2,3,4,5]\n\nputs num.at(2)\n\nputs num.at(-2)\n\n出力結果\n\n3\n\n4"},
{"class":"Array","name":"clear","detail":"clearメソッドは、要素を全て削除し、配列を空にします。レシーバ自身を変更するメソッドであり、戻り値はレシーバ自身です。\n\nexample\n\nnum = [1,2,3,4,5]\n\nnum.clear\n\np clear\n\n出力結果\n\n[]"},
{"class":"Array","name":"collect","detail":"collectメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値を集めた配列を作成して返します。mapメソッドはcollectメソッドの別名です。\n\nnum = [\"1\",\"2\",\"3\"]\n\np num.collect(&:to_i)\n\n出力結果\n\n[1,2,3]"},
{"class":"Array","name":"combination","detail":"combinationメソッドは、配列から引数n個の要素を選んだときの組合せ（順序なし、重複を許さない組合せ）を数え上げます。組合せの数だけブロックを繰り返し実行し、ブロック引数に組合せを配列で入れます。戻り値はレシーバ自身です。\n\nexample\n\nnum = [1,2,3,4]\n\nnum.combination(3){|a,b,c| print(\"(%d,%d,%d)\",a,b,c)}\n\nputs \"\"\n\n出力結果\n\n(1,2,3)(1,2,4)(1,3,4)(2,3,4)"},
{"class":"Array","name":"compact","detail":"compactメソッドは、配列からnilである要素を取り除いた新しい配列を返します。\n\nnum = [1,2,nil,3,nil,nil,5,nil,6]\n\np num.compact\n\n出力結果\n\n[1,2,3,4,5,6]"},
{"class":"Array","name":"count","detail":"countメソッドは、配列の引数と同じ要素の数を返します。引数を省略したときは配列の要素の数を返します。\n\nexample\n\nnum = [1,2,3,4,5,4,3,2,1,2,3]\n\nputs num.count(3)\n\nputs num.count\n\n出力結果\n\n3\n\n11\n\ncpuntメソッドにブロックを渡すと要素の数だけ繰り返しブロックを実行し、ブロックの戻り値が真になった要素の数を返します。\n\nnum = [1,2,3,4,5,6]\n\nputs num.count{|i| i % 2 == 0}\n\n出力結果\n\n3"},
{"class":"Array","name":"cycle","detail":"cycleメソッドは、配列の要素の数だけブロックを繰り返し実行し、その繰り返しを引数n回続けます。繰り返しごとにブロック引数には各要素が順に入ります。\n\nexample\n\nnum = [1,2,3]\n\nnum.cycle{|i| print\"#{i}\"}\n\nputs \"\"\n\n出力結果\n\n1 2 3 1 2 3"},
{"class":"Array","name":"delete","detail":"deleteメソッドは、配列から引数と同じ要素を探して、全て削除し、レシーバ自身を変更するメソッドであり、戻り値は削除した要素です。要素が見つからない場合はnilを返します。\n\nexample\n\nnum = [1,2,3,4,1,2]\n\nnum.delete(1)\n\np num\n\n出力結果\n\n[2,3,4,2]"},
{"class":"Array","name":"delete_at","detail":"delete_atメソッドは、配列から引数の位置の要素を削除します。レシーバ自身を変更するメソッドであり、戻り値は削除した要素です。引数が範囲外のときはnilを返します。\n要素の数や範囲を指定して削除したいときは、sliceメソッドを使います。\n\nexample\n\nnum = [1,2,3,4,5]\n\nnum.delete_at(1)\n\np num\n\n出力結果\n\n[1,3,4,5]"},
{"class":"Array","name":"delete_if","detail":"delete_ifメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値が真になった要素を削除し、レシーバ自身を変更するメソッドです。ブロック引数には各要素が入ります。\n\nreject!メソッドとは異なり、戻り値は常にレシーバ自身です。\n\nexample\n\nfruits = [\"apple\", \"orange\", \"banana\", \"kiwi\", \"peach\"]\n\nfruits.delete_if {|item| item =~ /^[aiueo]/ }\n\np fruits\n\n出力結果\n\n[\"banana\", \"kiwi\", \"peach\"]"},
{"class":"Array","name":"drop","detail":"dropメソッドは、配列の先頭から引数の要素を取り除き、残りで新しい配列を作成して返します。\n\nexample\n\nnum = [1,2,3,4,5,6]\n\np num.drop(3)\n\n出力結果\n\n[4,5,6]"},
{"class":"Array","name":"drop_while","detail":"drop_whileメソッドは、ブロックの戻り値が真である要素を配列の先頭から取り除き、残りの要素を集めた新しい配列を返します。ブロック引数itemに要素を入れながらブロックを繰り返し実行し、ブロックが偽を返すと繰り返しを中断して、それ以降の要素からなる配列を作成します。\n\nexample\n\nnum = [5,10,15,20,15,10]\n\np num.drop_while{|i| i <18}\n\n出力結果\n\n[20,15,10]"},
{"class":"Array","name":"each","detail":"eachメソッドは配列の要素の数だけブロックを繰り返し実行し、繰り返しごとにブロック引数には各要素が順に入ります。戻り値はレシーバ自身です。\n\nexample\n\nnum = [1,2,3,4]\n\nnum.each{|i| puts i}\n\n出力結果\n\n1\n2\n3\n4"},
{"class":"Array","name":"each_index","detail":"each_indexメソッドは、配列の要素の数だけブロックを繰り返し実行し、繰り返しごとにブロック引数には各要素のインデックスの整数が入り、戻り値はレシーバ自身です。\n\nexample\n\nanimals = [\"dog\",\"cat\",\"cow\"]\n\nanimals.each_index{|id| puts \"#{id}.#{animals[id]}\"}\n\n出力結果\n\n0.dog\n1.cat\n2.cow"},
{"class":"Array","name":"empty?","detail":"empty?メソッドは、配列が空であればtrue、1つ以上の要素があればfalseを返します。\n\nexample\n\narr = [1, 2, 3]\n\nputs arr.empty?\n\narr = []\n\nputs arr.empty?\n\n出力結果\n\nfalse\ntrue"},
{"class":"Array","name":"eql?","detail":"eql?メソッドは、ハッシュのキーが配列であるときに、「キーとして同じかどうか」を調べるために内部的に使われるメソッドです。\nレシーバarrayと引数other_arrayの各要素を順に比較して、それぞれが同じであればtrue、違いがあればfalseを返します。要素の比較には、各要素のeql?メソッドが使われます。\n配列の比較には、普通はeql?メソッドを使わずに、「配列の内容が同じかどうか」を調べるには==メソッドを、「同じオブジェクトかどうか」を調べるにはequal?メソッドを使ってください。\n\nexample\n\nnum = [1,2,3]\n\nputs num == [1.0,2.0,3.0]\n\nputs num.eql?([1.0,2.0,3.0])\n\n出力結果\n\ntrue\nfalse"},
{"class":"Array","name":"fetch","detail":"fetchメソッドは、配列から引数で指定した位置の要素を取り出して返します。atメソッドと機能は同じですが、位置が範囲外のときの動作が異なります。\nfetchメソッドに引数1つ（index）を整数で指定すると、その位置の要素を取り出して返します。indexが範囲外のときは、例外IndexErrorが発生します。\n\nexample\n\nnum = [1,2,3,4]\n\nputs num.fetch(2)\n\n出力結果\n\n3\n\n\n第2引数defaultを指定すると、indexが範囲外のときはdefaultを返します。\n\nexample\n\nnum = [1,2,3,4]\n\nputs num.fetch(7,\"nothing\")\n\n出力結果\n\nnothing"},
{"class":"Array","name":"fill","detail":"fillメソッドは、配列すべての要素を引数で置き換え、レシーバ自身を書き換えるメソッドであり、戻り値はレシーバ自身です。\n\nexample\n\narr = Array.new(3)\n\narr.fill(\"F\")\n\np arr\n\n出力結果\n\n[\"F\",\"F\",\"F\"]\n\nfillメソッドにブロックを渡すと、ブロックの戻り値で要素を置き換え、ブロック引数には要素の位置が入ります。メソッドの引数には、位置、要素の数、範囲を指定できます。\n\nexample\n\narr = Array.new(5,0)\n\narr.fill(2){|i| 2 * i}\n\np arr\n\n出力結果\n\n[0,0,6,8,10]"},
{"class":"Array","name":"first","detail":"firstメソッドは、配列の最初の要素を調べるメソッドで、配列が空の時はnilを返します。\n引数に整数を指定すると先頭からその数だけの要素を取り出して配列にして返し、配列が空のときは空の配列を返します。\n\nexamole\n\nnum = [1,2,3,4]\n\np num.first\n\np num.first(3)\n\n出力結果\n\n1\n[1,2,3]"},
{"class":"Array","name":"flatten","detail":"flattenメソッドは、配列の配列を平坦化した新しい配列を返し、配列中に含まれる配列からすべて要素を取り出して、親の配列の中に並べます。\n\nexample\n\narr = [[1,2,3],4,5,[6,[7,8]]]\n\n出力結果\n\n[1,2,3,4,5,6,7,8]"},
{"class":"Array","name":"frozen?","detail":"frozen?メソッドは、配列が凍結されていればtrue、凍結されていなければfalseを返します。\n\nexample\n\nnum = [1, 2, 3]\n\nputs num.frozen?\n\nnum.freeze\n\nputs num.frozen?\n\n出力結果\n\nfalse\ntrue"},
{"class":"Array","name":"hash","detail":"hashメソッドは、配列を元にハッシュ値を生成して返します。各要素のオブジェクトに対してhashメソッドを呼び出した結果を元にしてハッシュ値を作ります。\n\nexample\n\nanimals = [\"dog\", \"cat\", \"mouse\"]\n\nputs animals.hash\n\n出力結果\n\n651474064"},
{"class":"Array","name":"include?","detail":"include?メソッドは、配列の要素に引数objが含まれていればtrue、なければfalseを返します。要素と引数objが同じかどうかの比較には==メソッドが使われます。\n\nexample\n\nnum = [1,2,3]\n\nputs num.include?(1)\n\nputs num.include?(5)\n\n出力結果\n\ntrue\nfalse"},
{"class":"Array","name":"index","detail":"indexメソッドは、配列から引数objと同じ要素を探し、その位置を整数で返します#1番目が0、2番目が1、...。\n要素が見つからないときは、nilを返します。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.index(2)\n\np num.index(10)\n\n出力結果\n\n1\nnil"},
{"class":"Array","name":"insert","detail":"insertメソッドは、引数で指定した位置に引数を要素として挿入します。第2引数以降に複数の引数を並べると、複数の要素を順に挿入するレシーバ自身を変更するメソッドです。戻り値はレシーバ自身です。に範囲外の位置を指定すると、その位置に要素を挿入し、間をnilで埋めます。マイナスの値で範囲外の位置を指定すると例外IndexErrorが発生します。\n\nexample\n\nnum = [1,2,3,4,5]\n\nnum.insert(1,6)\n\nnum.insert(-1,7)\n\np num\n\n出力結果\n\n[1,6,2,3,4,5,7]"},
{"class":"Array","name":"inspect","detail":"inspectメソッドは、配列を読みやすい文字列に変換します。全体を[]で囲み、各要素をそれぞれinspectメソッドで文字列に変換し、カンマで区切った文字列を返します。\n\nexamoke\n\narray = [\"apple\", 123, Object.new]\n\nputs array.inspect\n\n出力結果\n\n[\"apple\", 123, #<Object:0x1a469a0>]"},
{"class":"Array","name":"join","detail":"joinメソッドは、配列の各要素を文字列に変換し、引数を区切り文字として結合した文字列を返します。\n引数のデフォルト値は組み込み変数の値です。変数の初期値はnilなので、引数を省略すると区切り文字なしで要素を結合した文字列になります。\n\nexample\n\nhello = [\"hello\",\"world\",\"!\"]\n\nputs hello.join(\",\")\n\nputs hello.join\n\n出力結果\n\nhello,world,!\nhelloworld!"},
{"class":"Array","name":"keep_if","detail":"keep_ifメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値が真になった要素を残し、偽になった要素を削除し、レシーバ自身を変更するメソッドです。ブロック引数には各要素が入ります。\n\nexample\n\nfruits = [\"apple\",\"orange\",\"banana\",\"kiwi\", \"peach\"]\n\nfruits.keep_if {|i| i =~ /^[aiueo]/ }\n\np fruits\n\n出力結果\n\n[\"apple\",\"orange\"]"},
{"class":"Array","name":"last","detail":"lastメソッドは、配列の最後の要素を返し、配列が空のときはnilを返します。\n引数に整数を指定すると、末尾からその数だけ要素を取り出して、配列にして返します。配列が空のときは空の配列を返します。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.last\n\np num.last(2)\n\n出力結果\n\n5\n[4,5]"},
{"class":"Array","name":"length","detail":"lengthメソッドは配列の要素の数を整数で返します。sizeメソッドと同じ働きです。\n\nexample\n\nnum = [1,2,3]\n\nputs num.length\n\n出力結果\n\n3"},
{"class":"Array","name":"map","detail":"mapメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値を集めた配列を作成して返します。collectメソッドの別名です。\n\nnum = [\"1\",\"2\",\"3\"]\n\np num.map(&:to_i)\n\n出力結果\n\n[1,2,3]"},
{"class":"Array","name":"pack","detail":"packメソッドは、引数formatの書式に従って配列の要素からバイト列を作成し、文字列として返します。\n\nexample\n\nnum = [0x7552, 0x7962]\n\nputs numbers.pack(\"S2\")\n\n出力結果\n\nRuby"},
{"class":"Array","name":"permutation","detail":"permutationメソッドは、配列から引数n個の要素を選んだときの順列（順序あり、重複を許さない組合せ）を数え上げます。組合せの数だけブロックを繰り返し実行し、ブロック引数に組合せを配列で入れます。戻り値はレシーバ自身です。引数を省略したときは、配列の要素数がnになります。\n\nexample\n\nnum = [1, 2, 3, 4]\n\nnum.permutation(2) {|a, b| printf(\"(%d, %d) \", a, b) }\n\nputs \"\"\n\n出力結果\n\n(1, 2) (1, 3) (1, 4) (2, 1) (2, 3) (2, 4) (3, 1) (3, 2) (3, 4) (4, 1) (4, 2) (4, 3)"},
{"class":"Array","name":"pop","detail":"popメソッドは、配列の末尾の要素を削除し、その要素を返し、レシーバ自身を変更するメソッドです。配列が空のときはnilを返します。\n\nexample\n\nnum = [1,2,3]\n\nnum.pop\n\np num\n\n出力結果\n\n[1,2]"},
{"class":"Array","name":"rassoc","detail":"rassocメソッドは、配列の配列を連想配列のように扱い、キーの値に対応する配列を取り出します。配列の配列の中で、2番目の要素が引数valと同じ配列を探して返します。見つからないときはnilを返し、要素と引数valの比較には、==演算子が使われます。\n\nexample\n\nperson = [[\"name\",\"John\"],[\"age\",\"18\"],[\"hobby\",\"baseball\"]]\n\np person.rassoc(\"18\")\n\n出力結果\n\n[\"age\",\"18\"]"},
{"class":"Array","name":"reject","detail":"rejectメソッドは、要素の数だけ繰り返しブロックを実行し、ブロックの戻り値が偽である要素を集め、新しい配列を作ります。ブロック引数には各要素が入ります。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.reject{|i| i % 2 == 0}\n\n出力結果\n\n[1,3,5]"},
{"class":"Array","name":"repeated_combination","detail":"repeated_combinationメソッドは、配列の要素から引数n個を選んだときの重複組合せ（順序なし、重複を許す組合せ）を数え上げます。組合せの数だけブロックを繰り返し実行し、ブロック引数に組合せを配列で入れ、戻り値はレシーバ自身です。\n\nexample\n\nnum = [1, 2, 3, 4]\n\nnum.repeated_combination(3) {|a, b, c| printf(\"(%d, %d, %d) \", a, b, c) }\n\nputs \"\"\n\n出力結果\n\n(1, 1, 1) (1, 1, 2) (1, 1, 3) (1, 1, 4) (1, 2, 2) (1, 2, 3) (1, 2, 4) (1, 3, 3) (1, 3, 4) (1, 4, 4) (2, 2, 2) (2, 2, 3) (2, 2, 4) (2, 3, 3) (2, 3, 4) (2, 4, 4) (3, 3, 3) (3, 3, 4) (3, 4, 4) (4, 4, 4)"},
{"class":"Array","name":"repeated_permutation","detail":"repeated_permutationメソッドは、配列の要素から引数n個を選んだときの重複順列（順序あり、重複を許す組合せ）を数え上げます。組合せの数だけブロックを繰り返し実行し、ブロック引数arrに組合せを配列で入れ、戻り値はレシーバ自身です。\n\nexample\n\nnum = [1, 2, 3, 4]\n\nnum.repeated_permutation(2) {|a, b| printf(\"(%d, %d) \", a, b) }\n\nputs \"\"\n\n出力結果\n\n(1, 1) (1, 2) (1, 3) (1, 4) (2, 1) (2, 2) (2, 3) (2, 4) (3, 1) (3, 2) (3, 3) (3, 4) (4, 1) (4, 2) (4, 3) (4, 4)"},
{"class":"Array","name":"replace","detail":"replaceメソッドは、配列の内容を引数のもので置き換え、レシーバ自身を変更するメソッドであり、戻り値はレシーバ自身です。\n\nexample\n\nnum = [1,2,3,4,5]\n\nnum.replace([6,7,8])\n\np num\n\n出力結果\n\n[6,7,8]"},
{"class":"Array","name":"reverse","detail":"reverseメソッドは、配列の要素の順番を反転させた新しい配列を返します。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.reverse\n\n出力結果\n\n[5,4,3,2,1]"},
{"class":"Array","name":"reverse_each","detail":"reverse_eachメソッドは、配列の要素の数だけブロックを繰り返し実行します。繰り返しごとにブロック引数には各要素が末尾から逆順に入り、戻り値はレシーバ自身です。\n\nexample\n\nnum = [1,2,3,4,5]\n\nnum.reverse_each {|i| puts i}\n\n出力結果\n\n5\n4\n3\n2\n1"},
{"class":"Array","name":"rindex","detail":"rindexメソッドは、配列の末尾から順に引数objと同じ要素を探し、その位置（インデックス）を整数で返します。要素が見つからないときは、nilを返します。要素と引数が同じかどうかの比較には==演算子が使われます。\n\nexample\n\nnum = [1,2,3,4,3,2,1]\n\nputs num.rindex(3)\n\n出力結果\n\n4"},
{"class":"Array","name":"rotate","detail":"rotateメソッドは、要素を回転させるように前後に移動した新しい配列を返します。引数に正の数を指定すると、要素をその数だけ前に動かし、先頭の要素を末尾に回し、負の数を指定すると、要素を後ろに動かし、末尾の要素を先頭に回し、引数を省略すると、1つ前に動かします。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.rotate(4)\n\n出力結果\n\n[5,1,2,3,4]"},
{"class":"Array","name":"sample","detail":"sampleメソッドは、配列の要素を1つランダムに返します。配列が空の場合はnilを返します。\n\nexample\n\nnum = [1,2,3,4]\n\nputs num.sample\n\n出力結果\n\n4 #実行ごとに違う"},
{"class":"Array","name":"select","detail":"selectメソッドは、条件に合う要素を探して集めます。ブロック引数に要素を入れながらブロックを繰り返し、ブロックの戻り値が真になったときの要素を集め、新しい配列にして返します。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.select{|i|i % 2 == 0}\n\n出力結果\n\n[2,4]"},
{"class":"Array","name":"shift","detail":"shiftメソッドは、配列の最初の要素を削除し、その要素を返します。レシーバ自身を変更するメソッドです。配列が空のときはnilを返します。\n\nexample\n\nnum = [1,2,3]\n\nnum.shift\n\np num\n\n出力結果\n\n[2,3]"},
{"class":"Array","name":"shuffle","detail":"shuffleメソッドは、配列の要素の順番をランダムに入れ替えた新しい配列を返します。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.shuffle\n\n出力結果\n\n[4,2,5,3,1] #実行ごとに違う"},
{"class":"Array","name":"size","detail":"sizeメソッドは、配列の要素の数を整数で返します。\n\nnum = [1,2,3]\n\nnum.size\n\n出力結果\n\n3"},
{"class":"Array","name":"slice","detail":"sliceメソッドは、[]メソッドの別名です。配列から引数で指定した位置の要素を取り出して返します。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.slice(3)\n\n出力結果\n\n4"},
{"class":"Array","name":"sort","detail":"sortメソッドは、配列の要素をソートした新しい配列を返します。要素の順序の比較には<=>演算子が使われ、「要素1 <=> 要素2」の結果が-1なら要素1が先、0なら同じ、1なら要素2が先となります。\n\nexample\n\nnum = [5,6,4,2,8,1]\n\np num.sort\n\n出力結果\n\n[1,2,4,5,6,8]"},
{"class":"Array","name":"sort_by!","detail":"sort_by!メソッドは、ブロックを使って要素をソートします。レシーバ自身を変更するメソッドです。ブロック引数に要素を入れながらブロックを繰り返し実行し、ブロックの戻り値を集めます。集めた戻り値を<=>演算子で比較して、小さい順に要素を並べます。\n\nexample\n\nanimals = [\"mouse\", \"cat\", \"hippopotamus\", \"giraffe\"]\n\nanimals.sort_by!{|i| i.size}p animals\n\n出力結果\n\n[\"cat\",\"mouse\",\"giraffe\",\"hipopotamus\"]"},
{"class":"Array","name":"take","detail":"takeメソッドは、配列の先頭から引数n個の要素を取り出して、新しい配列を作成して返します。\n\nexample\n\nnum = [1,2,3,4,5,6]\n\np num.take(3)\n\n出力結果\n\n[1,2,3]"},
{"class":"Array","name":"take_while","detail":"take_whileメソッドは、ブロックの戻り値が真である要素を配列の先頭から取り出し、新しい配列に入れて返します。ブロック引数に要素を入れながら、ブロックの戻り値が真である間はブロックを繰り返します。ブロックが偽を返すと繰り返しを中断して、それより前の要素からなる配列を作成します。\n\nexample\n\nnum = [1,35,23,43,54,32,65,11]\n\np num.take_while{|i| i < 50}\n\n出力結果\n\n[1,35,23,43]"},
{"class":"Array","name":"transpose","detail":"transposeメソッドは、配列の配列を行と列からなるデータと見立てて、行と列を入れ替えた配列の配列を作成して返します。\n\nexample\n\nnum = [[1, 2, 3],[4, 5, 6]]\n\np num.transpose\n\n出力結果\n\n[[1,4],[2,5],[3,6]]"},
{"class":"Array","name":"uniq","detail":"uniqメソッドは、配列の中で重複する要素を削除した新しい配列を返します。\n\nexample\n\nnum = [1,2,5,5,1,3,1,2,4,3]\n\np num.uniq\n\n出力結果\n\n[1,2,5,3,4]"},
{"class":"Array","name":"unshift","detail":"unshiftメソッドは、引数objを配列の先頭に要素として追加します。引数を複数指定すると、それぞれ先頭から順に追加します。レシーバ自身を変更し、戻り値はレシーバ自身です。\n\nexamole\n\nnum = [1,2,3]\n\nnum.unshift(4)\n\np num\n\n出力結果\n\n[4,1,2,3]"},
{"class":"Array","name":"values_at","detail":"values_atメソッドは、配列から引数で指定した位置の要素を取り出し、配列にして返します。引数は複数指定できます。引数に範囲を指定すると、その範囲の位置から要素を取り出します。\n\nexample\n\nnum = [1,2,3,4,5]\n\np num.value_at(0,3,5)\n\n出力結果\n\n[1,4,nil]"},
{"class":"Array","name":"zip","detail":"zipメソッドは、配列の要素を引数の配列other_arrayの要素と組み合わせ、配列の配列を作成して返します。transposeメソッドで[array, other_array, ...].transposeとしたときと同じく、行と列を入れ替えます。ただし、transposeメソッドと違って足りない要素はnilで埋められ、余分な要素は捨てられます。\n\nexample\n\nnum1 = [1,2,3]\n\nnum2 = [4,5]\n\nnum3 = [6,7,8,9]\n\np num1.zip(num2,num3)\n\nexample\n\n出力結果\n\n[[1,4,6],[2,5,7],[3,nil,8]]"}
]