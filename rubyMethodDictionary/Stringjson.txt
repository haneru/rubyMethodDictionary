[{"class":"String","name":"%","detail":"%演算子（メソッド）は、書式付き文字列を作成します。左辺の文字列strで表した書式に右辺のargを埋め込んで、新しい文字列を返します。\n\nexample\n\nnum = 10.0 / 3\n\nputs \"%.4f\"%num\n\n出力結果\n\n3.3333"},
{"class":"String","name":"*","detail":"*演算子（メソッド）は、左辺の文字列strを右辺の数integerだけ繰り返し並べた文字列を返します。\n\nexample\n\nstr = \"Hello\"\n\nputs str * 3\n\n出力結果\n\nHelloHelloHello"},
{"class":"String","name":"+","detail":"+メソッド（演算子）は、2つの文字列を連結した新しい文字列を返します。\n\nexample\n\ns = \"Hello\"\n\nputs s + \", world\"\n\n出力結果\n\nHello, world"},
{"class":"String","name":"<<","detail":"<<演算子（メソッド）は、文字列の末尾に別の文字列を加えます。+とは違い、レシーバ自身の文字列を変更します。戻り値はレシーバ自身です。\nconcatメソッドは<<の別名です。\n\nexample\n\ns = \"Hello\"\n\ns << \", world\"\n\nputs s\n\n出力結果\n\nHello,world"},
{"class":"String","name":"<=>","detail":"<=>演算子（メソッド）は、2つの文字列の辞書的な順番を調べます。左辺が先なら-1、同じなら0、右辺が先なら1を返します。右辺がStringオブジェクトでないときはnilが返ります。\n\nexample\n\nword1 \"happily\"\n\nword2 = \"happines\"\n\nputs word1 <=> word2\n\n出力結果\n\n-1"},
{"class":"String","name":"=~","detail":"=~演算子（メソッド）は、文字列に対して正規表現とのパターンマッチを行います。マッチしたときは、マッチした部分の位置を整数で返します。マッチしなかったら、nilを返します。\n右辺にRegexp以外のオブジェクトを指定するとfalseが返ります。ただし、右辺に文字列を指定したときは、例外TypeErrorが発生します。\n=~でマッチに成功したときは、組み込み変数$&、$1、$2などに値がセットされます。次の例では、文字列とパターン/<(.+)>/をマッチさせ、< >に囲われた語句を変数$1で取り出しています。\n\nexample\n\nstr = \"hello <ruby> world\"\n\nif str =~ /<(￥w+)>/\n\nputs $1\n\nend\n\n出力結果\n\nruby"},
{"class":"String","name":"[]","detail":"[]は、文字列の中から部分文字列を取り出すメソッドです。s[2]、s[3,5]、s[2..7]、s[/[0-9]/] のように、いろいろな形で利用できます。配列要素の取り出しのように記述しますが、実際にはメソッド呼び出しです。[]の中はメソッドの引数です。\n引数に整数を1つ指定すると、その位置の文字を返します。バイトごとではなく文字ごとの位置です。\n\nexample\n\ns = \"hello\"\n\nputs s[1]\n\nputs s[-2]\n\ns = \"こんにちは\"\n\nputs s[1]\n\n出力結果\n\ne\nl\nん"},
{"class":"String","name":"[]=","detail":"[]=メソッドは、str[idx] = new_strのように記述することで、[]内で指定した部分文字列を右辺の文字列で置き換えます。strがレシーバで、[]内のindexと右辺が引数です。レシーバ自身を変更するメソッドです。戻り値は常に右辺です。\n[]メソッドと同じく、[]内には位置だけでなく、位置と数、範囲、正規表現、文字列を指定できます。詳しくは[]メソッドをご覧ください。\n[]内に整数を1つ指定して、右辺に文字列を置くと、整数の位置の文字を置き換えます。\n\nexample\n\ns = \"hello\"\n\ns[4] = \"oooo\"\n\nputs s\n\n出力結果\n\nhelloooo"},
{"class":"String","name":"ascii_only?","detail":"ascii_only?メソッドは、文字列中に含まれる文字がアスキー文字だけならtrue、アスキー文字以外の文字があればfalseを返します。\n\nexample\n\ns = \"Très bien.\"\n\nt = \"Hello.\"\n\nputs s.ascii_only?\n\nputs t.ascii_only?\n\n出力結果\n\nfalse\ntrue"},
{"class":"String","name":"bytes","detail":"bytesメソッドは、文字列中のバイトを繰り返し取り出します。ブロック引数fixnumにバイトのコードを整数で入れながら、バイト数だけブロックを繰り返し、戻り値はレシーバ自身です。\n\nexample\n\ns = \"あ\"\n\ns.bytes {|b| print b.to_s(16) + \" \" }\n\nputs \"\"出力結果\n\ne3 81 82"},
{"class":"String","name":"bytesize","detail":"bytesizeメソッドは、文字列中のバイト数を返します。\n\nexample\n\nmessage = \"こんにちは\"\n\nputs message.bytesize\n\n出力結果\n\n15"},
{"class":"String","name":"capitalize","detail":"capitalizeメソッドは、先頭の小文字を大文字にした新しい文字列を返します。先頭以外のアルファベットはすべて小文字にします。\n\nexample\n\ns = \"heLLO, World\"\n\nputs s.capitalize\n\n出力結果\n\nHello, world"},
{"class":"String","name":"casecmp","detail":"casecmpメソッドは、文字列と引数の文字列を大文字小文字の区別をしないで比較します。<=>演算子と同様にレシーバが先なら-1、同じなら0、後なら1を返します。\n\nexample\n\nword1 = \"happily\"\n\nword2 = \"Happines\"\n\nword3 = \"HAPPILY\"\n\nputs word1.casecmp(word2)\n\nputs word1.casecmp(word3)\n\n出力結果\n\n-1\n0"},
{"class":"String","name":"center","detail":"centerメソッドは、引数の長さを持つ新しい文字列を作成し、レシーバの文字列をその中央に置いて、左右を空白で埋めます。引数padstrが指定されていれば、空白の代わりにその文字列で埋めます。\n\nexample\n\ns = \"hello\"\n\np s.center(15)\n\n出力結果\n\n\"     hello     \""},
{"class":"String","name":"chars","detail":"charsメソッドは、文字列中の文字を繰り返し取り出します。ブロック引数に1文字を入れながら、文字数だけブロックを繰り返します。戻り値はレシーバ自身です。\n\nexample\n\ns= \"hello\"\n\ns.chars{|s| print s + \" \"}\n\nputs \"\"\n\n出力結果\n\nh e l l o "},
{"class":"String","name":"chomp","detail":"chompメソッドは、文字列の末尾の改行文字を取り除いた新しい文字列を返します。\n\nexample\n\n unix\"hello\\n\"\n\np unix.chomp\n\n出力結果\n\n\"hello\""},
{"class":"String","name":"chr","detail":"chrメソッドは、文字列の最初の1文字を新しい文字列で返します。\n\nexample\n\ns = \"abcde\"\n\nputs s.chr\n\n出力結果\n\na"},
{"class":"String","name":"clear","detail":"clearメソッドは、文字列を空文字列に変えます。レシーバ自身を変更し、戻り値はレシーバ自身です。\n\nexample\n\ns = \"Hello\"\n\ns.clear\n\np s\n\n出力結果\n\n\"\""},
{"class":"String","name":"concat","detail":"concatメソッドは、<<の別名です。文字列の末尾に別の文字列を加えます。整数で文字のコードを指定すると、文字列の末尾に1文字追加します。\n\nexample\n\ns = \"Hello\"\n\ns.concat(\", world\")\n\nputs s\n\n出力結果\n\nHello,world"},
{"class":"String","name":"count","detail":"countメソッドは、引数で指定した文字の数を文字列の中から調べ、整数を返します。\n\nexample\n\ns = \"hello, world\"\n\nputs s.count(\"l\")\n\n出力結果\n\n3"},
{"class":"String","name":"delete","detail":"deleteメソッドは、引数で指定した文字を文字列の中から削除し、新しい文字列を返します。引数の指定のしかたはcountメソッドと同じです。\n\nexample\n\ns = \"hello, world\"\n\nputs s.delete(\"l\")\n\n出力結果\n\nheo,word"},
{"class":"String","name":"downcase","detail":"downcaseメソッドは、文字列中の大文字を小文字に変えた新しい文字列を返します。\n\nexample\n\ns = \"HELLO,WORLD\"\n\nputs s.downcase\n\n出力結果\n\nhello,world"},
{"class":"String","name":"each_line","detail":"each_lineメソッドは、文字列を改行文字で分割して1行ずつ取り出します。ブロック引数lineに1行の文字列を入れながら、行数だけブロックを繰り返します。戻り値はレシーバ自身です。\n取り出された文字列の末尾には改行文字がついたままになります。改行文字を取り除くにはchompメソッドを使います。\"\\r\"はデフォルトでは改行文字と見なされません。\n\nexample\n\ns = \"line 1.\\nline 2.\\r\\nline 3.\\rline 4.\"\n\ns.each_line {|s|p s.chomp }\n\n出力結果\n\n\"line 1.\"\n\"line 2.\"\n\"line 3.\\rline 4.\""},
{"class":"String","name":"empty?","detail":"empty?メソッドは、文字列が空文字列（長さがゼロ）ならtrue、空でなければfalseを返します。\n\nexample\n\ns = \"Hello\"\n\nputs s.empty?\n\nt = \"\"\n\nputs t.empty?\n\n出力結果\n\nfalse\ntrue"},
{"class":"String","name":"end_with?","detail":"end_with?メソッドは、文字列の末尾が引数の文字列で終わっていればtrue、そうでなければfalseを返します。\n\nexample\n\ns = \"hello,world\"\n\nputs s.end_with?(\"rld\")\n\n出力結果\n\ntrue"},
{"class":"String","name":"eql?","detail":"eql?メソッドは、ハッシュのキーが文字列であるときに、「同じキーかどうか」を調べるために内部的に使われるメソッドです。レシーバと引数の文字列の内容が同じならtrue、違えばfalseを返します。\n\nexample\n\ns = \"hello\"\n\nputs s.eql?(\"world\")\n\nputs s.eql?(\"hello\")\n\n出力結果\n\nfalse\ntrue"},
{"class":"String","name":"getbyte","detail":"getbyteメソッドは、文字列の中から引数の位置のバイトを整数で返します（0が1番目、1が2番目、...）。範囲外の位置を指定するとnilを返します。\n\nexample\n\ns = \"漢字ABC\"\n\nputs s.getbyte(1)\n\nputs s.getbyte(-3)\n\n出力結果\n\n188\n65"},
{"class":"String","name":"include?","detail":"include?メソッドは、文字列の中に引数の文字列が含まれるかどうかを調べます。含まれるときはtrue、含まれないときはfalseを返します。\n\nexample\\ns = \"hello,world\"\n\nputs s.include?(\"ell\")\n\n出力結果\n\ntrue"},
{"class":"String","name":"index","detail":"indexメソッドは、文字列の中に部分文字列が含まれていれば、その開始位置を整数で返します（0が1番目、1が2番目、...）。含まれていなければnilを返します。\n第2引数を指定すると、その位置から検索を開始します。負の値を指定すると末尾からの位置になります。#-1が末尾から1番目、-2が末尾から2番目、...\n\nexample\n\ns = \"hello,world\"\n\nputs s.index(\"l\")\n\nputs s.index(\"l\",5)\n\n出力結果\n\n2\n9"},
{"class":"String","name":"insert","detail":"insertメソッドは、文字列の中で引数の位置に別の文字列を挿入し、レシーバ自身を変更するメソッドです。戻り値はレシーバ自身です。\n\ns = \"hello, world\"\n\ns.insert(7, \"ruby \")\n\nputs s\n\n出力結果\n\nhello, ruby world"},
{"class":"String","name":"intern","detail":"internメソッドは、文字列に対応するシンボル（Symbolオブジェクト）を返します。\n\nexample\n\ns = \"hello\"\n\np s.intern\n\n出力結果\n\n:hello"},
{"class":"String","name":"length","detail":"lengthメソッドは、文字列中の文字の数を返します。\n\nexample\n\ns = \"Hello\"\n\nputs s.length\n\n出力結果\n\n5"},
{"class":"String","name":"ljust","detail":"ljustメソッドは、引数の長さを持つ新しい文字列を作成し、レシーバstrの文字列をその左端に置いて、右側を空白で埋めます。第二引数が指定されていれば、空白の代わりにその文字列で埋めます。\n\nexample\n\ns = \"hello\"\n\np s.ljust(10,\"a\")\n\n出力結果\n\n\"helloaaaaa\""},
{"class":"String","name":"lstrip","detail":"lstripメソッドは、文字列の先頭の空白文字を除去した新しい文字列を返します。\n\nexample\n\ns = \"    hello,world\"\n\np s.lstrip\n\n出力結果\n\n\"hello,world\""},
{"class":"String","name":"ord","detail":"ordメソッドは、文字列の最初の文字のコードポイントを返します。コードポイントとは、1文字を表す整数のコードです。\n\nexample\n\ns = \"あいうえお\"printf(\"%x\n\", s.ord)\n\nexample\n\n3042"},
{"class":"String","name":"partition","detail":"partitionメソッドは、部分文字列で文字列を分割し、[前の部分, 部分文字列, 後の部分]という配列を返します。\n\nexample\n\ns = \"hello\"\n\np s.partition(\"e\")\n\np s.partition(\"a\")\n\n出力結果\n\n[\"h\",\"e\",\"llo\"]\n[\"hello\",\"\",\"\"]"},
{"class":"String","name":"reverse","detail":"reverseメソッドは、文字列の文字の順番を反転させた新しい文字列を返します。\n\ns = \"hello\"\n\nputs s.reverse\n\n出力結果\n\nolleh"},
{"class":"String","name":"rindex","detail":"rindexメソッドは、文字列の末尾から部分文字列を探し、その開始位置を整数で返します。含まれていなければnilを返します。戻り値は末尾からの位置ではなく先頭からの位置です。（0が1番目、1が2番目、...\n第2引数を指定すると、その位置から先頭に向かって検索します。offsetは末尾からの位置ではなく先頭からの位置です。負の値を指定すると末尾からの位置になります。 #-1が末尾から1番目、-2が末尾から2番目、...\n\nexample\n\ns = \"Supercalifragilisticexpialidocious\"\n\nputs s.rindex(\"li\")\n\nputs s.rindex(\"li\",-10)\n\n出力結果\n\n25\n14"},
{"class":"String","name":"rjust","detail":"rjustメソッドは、引数の長さを持つ新しい文字列を作成し、レシーバの文字列をその右端に置いて、左側を空白で埋めます。第二引数が指定されていれば、空白の代わりにその文字列で埋めます。\n\nexample\n\ns = \"hello\"\n\np s.rejust(15)\n\n出力結果\n\n\"          hello\""},
{"class":"String","name":"rstrip","detail":"rstripメソッドは、文字列の末尾の空白文字を除去した新しい文字列を返します。\n\nexample\n\ns = \"hello,world \\ｒ\\ｎ\"\np s.rstrip\n\n出力結果\n\n\"hello,world\""},
{"class":"String","name":"split","detail":"splitメソッドは、引数を区切り文字として文字列を分割し、配列を返します。引数の指定のしかたによってさまざまな分割ができます。分割できなかったときは、要素が文字列1つだけの配列を返します。\n\nexample\n\ns = \"hello,world\"\n\n p s.split(\",\")\n\n出力結果\n\n[\"hello\",\"world\"]"},
{"class":"String","name":"start_with?","detail":"start_with?メソッドは、文字列の先頭が引数の文字列で始まっていればtrue、そうでなければfalseを返します。\n\nexample\n\ns = \"hello,world\"\n\nputs s.start_with?(\"hel\")\n\n出力結果\n\ntrue"},
{"class":"String","name":"strip","detail":"stripメソッドは、文字列の先頭と末尾の空白文字を除去した新しい文字列を返します。\n\nexample\n\ns = \"  hello, world  \\r\\n\"\n\np s.strip\n\n出力結果\n\n\"hello,world\""},
{"class":"String","name":"to_f","detail":"to_fメソッドは、文字列を浮動小数点数の表現と見なしてFloatオブジェクトに変換します。\n文字列の先頭から浮動小数点数と見なせる部分を切り取って変換します。見なせる部分がなければ0.0を返します。\n\nexample\n\ns = \"1.2345\"puts s.to_f\n\n出力結果\n\n1.2345"},
{"class":"String","name":"to_i","detail":"to_iメソッドは文字列を１０進数とみなして整数に変換します。みなせないものは０になります。\n\nexample\n\ns = \"2015\"\n\nputs s.to_i\n\n出力結果\n\n2015"},
{"class":"String","name":"to_s","detail":"to_sメソッドは、レシーバ自身を返します。レシーバのクラスがStringのサブクラスである場合は、文字列をコピーして新しく作成したStringオブジェクトを返します。\n\nexample\n\ndef cat(s1,s2)\n   d1.to_s + s2.to_s\nend\n\nputs cat(\"hello\",123)\n\nputs cat(456,\"hello\")\n\n出力結果\n\nhello123\n456hello"},
{"class":"String","name":"dummy","detail":"trメソッドは、文字列の中で引数に並べた文字を第二引数に並べた文字に置き換え、新しい文字列を返します。\n\nexample\n\ns = \"dummy\"\n\nputs s.tr(\"dm\",\"cr\")\n\n出力結果\n\ncurry"},
{"class":"String","name":"tr_s","detail":"tr_sメソッドは、trメソッドと同様に、引数に並べた文字を第二引数に並べた文字に置換します。さらに、置換した文字が連続している場合は文字1つに置き換えて、新しい文字列を返します。\n\nexample\n\ns = \"11223344\"\n\nputs s.tr_s(\"1-9\",\"A-I\")\n\n出力結果\n\nABCD"},
{"class":"String","name":"upcase","detail":"upcaseメソッドは、文字列中の小文字を大文字に変えた新しい文字列を返します。\n\nexample\n\ns = \"hello, world\"\n\nputs s.upcase\n\n出力結果\n\nHELLO, WORLD"},
]